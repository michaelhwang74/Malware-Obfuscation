from collections import OrderedDict
import re
import numpy as np

class AsmValues:
    subRoutineLengthCutOff = 500

    def __init__(self, opCodeFilter):
        self.__values = {}
        self.__values['freq'] = OrderedDict()
        for opCode in opCodeFilter: #start the freq count for desired opcodes at 0
            self.__values['freq'][opCode] = 0
        self.__values['operandTypeCount'] = [0, 0, 0, 0, 0] #immediate, register, direct address, indirect address, identifier token
        self.__values['numOperands'] = [0, 0, 0] # frequency of instructions with 0,1,2 operands 
        self.__values['controlFlowCount'] = 0
        self.__values['totalLines'] = 0

        self.__procCounts = []
        self.__pCounter = 0
        self.__pStartCount = False

        
    def procCounter(self, line):
        if self.__pStartCount:
            self.__pCounter += 1

        if re.match("^(.+) proc near", line):
            self.__pStartCount = True

        if re.match("^(.+) endp", line):
            self.__pStartCount = False
            if self.__pCounter < AsmValues.subRoutineLengthCutOff:
                self.__procCounts.append(self.__pCounter)
            self.__pCounter = 0


        return None

    def countOpFreq(self, opCode):            
        if opCode in self.__values['freq'].keys():#increment frequency count
            self.__values['freq'][opCode] = self.__values['freq'][opCode] + 1
    def countControl(self, opCode):
        if opCode and (opCode[0] == 'j' or opCode == 'call'):#if not empty and starts with j
            self.__values['controlFlowCount'] += 1

    def countOperandTypes(self, parsedLine):#only call if there are 2 operands
        for i in range(2):
            operand = parsedLine[i+1]
            if AsmValues.isImmediate(operand):
                self.__values['operandTypeCount'][0] += 1
            elif AsmValues.isRegister(operand):
                self.__values['operandTypeCount'][1] += 1
            elif AsmValues.isAddress(operand):
                if AsmValues.isIndirect(operand):
                    self.__values['operandTypeCount'][3] += 1
                else:
                    self.__values['operandTypeCount'][2] += 1
            else:
                self.__values['operandTypeCount'][4] += 1

    def countLine(self):
        self.__values['totalLines'] += 1
        
    def countNumOperands(self, parsedLine):
        if parsedLine[2]:
            self.__values['numOperands'][2] += 1
        elif parsedLine[1]:
            self.__values['numOperands'][1] += 1
        else:
            self.__values['numOperands'][0] += 1
    
    def getValues(self):
        procAvg = np.average(self.__procCounts)
        procTotal = np.sum(self.__procCounts)
        procStd = np.std(self.__procCounts)
        self.__values['procStats'] = [procTotal, procAvg, procStd]
        return self.__values

    def isRegister(line):
        return re.match("^r[0-9]{1,2}[a-z]?$|^[a-z]{2,3}$|^[a-d][lh]$|^[xy]mm[0-9]$", line)
    def isImmediate(line):
        return re.match("^[0-9][0-9a-f]*h$|^[0-9]+$", line)
    def isAddress(line):
        return re.search("\\[.+\\]", line)
    def isIndirect(line): #should be called after isAddress
        return re.search("[\\+\\-\\*]", line)

    def tempTest(parsedLine):#test if regex's capture all operands
        if (not AsmValues.isRegister(parsedLine[1]) and not AsmValues.isImmediate(parsedLine[1]) and not AsmValues.isAddress(parsedLine[1])) or (not AsmValues.isRegister(parsedLine[2]) and not AsmValues.isImmediate(parsedLine[2]) and not AsmValues.isAddress(parsedLine[2])):
            print(parsedLine)
            