import random
import re

class Obfuscator:
    def __initRegisters(self):
        for reg in range(1,15):
            self.registers.append("r"+str(reg))

        self.registers.append("eax")
        self.registers.append("ebx")
        self.registers.append("ecx")
        self.registers.append("edx")
        self.registers.append("rax")
        self.registers.append("rbx")
        self.registers.append("rcx")
        self.registers.append("rdx")
    def __initInstructions(self):
        twoOperand = ['add', 'and', 'mov', 'or', 'sub', 'xor', 'mul', 'shl', 'shr', 'ror', 'rol', 'lea']
        oneOperand = ['not', 'inc', 'dec']
        noOperand = ['nop']
        controlOperand = ['jmp', 'ja', 'jb', 'jbe', 'je', 'jg', 'jne', 'jnp', 'jp', 'jz']
        self.instructions['one'] = oneOperand
        self.instructions['two'] = twoOperand
        self.instructions['zero'] = noOperand
        self.instructions['control'] = controlOperand


    def __init__(self):
        self.registers = []
        self.instructions = {}

        self.__initRegisters()
        self.__initInstructions()
        print(self.registers)

    def dexToHex(number):
        return hex(number)[2:]+'h'

    def randReg(self):
        return self.registers[random.randrange(len(self.registers))]
    def randImmediate(self):
        return Obfuscator.dexToHex(random.randrange(2**16))

    def parseLine(line):
        groups = re.match("(\\S+)( ([^,\n]*([^, \n])))? ?(, (\\S+))?", line).groups()
        return [groups[0], groups[2], groups[5]]

    def randOpcode(self, key):
        opcodeSet = self.instructions[key]
        return opcodeSet[random.randrange(len(opcodeSet))]
    def genRandInstruction(self):
        choice = random.randrange(100)
        fullInstruction = []
        if choice < 80:#80% of random instructions should have 2 operands
            fullInstruction.append(self.randOpcode('two'))
            fullInstruction.append(self.randReg())
            isRegister = random.choice([True, False])
            if isRegister:
                fullInstruction.append(self.randReg())
            else:
                fullInstruction.append(self.randImmediate())
        elif choice < 90:
            fullInstruction.append(self.randOpcode('one'))
            fullInstruction.append(self.randReg())
            fullInstruction.append(None)
        else:
            fullInstruction.append(self.randOpcode('zero'))
            fullInstruction.append(None)
            fullInstruction.append(None)
        return fullInstruction

    def randTargetedInstruction(self, target):
        choice = random.randrange(100)
        fullInstruction = []
        if choice < 80:
            fullInstruction.append(self.randOpcode('two'))
            fullInstruction.append(target)
            isRegister = random.choice([True, False])
            if isRegister:
                fullInstruction.append(self.randReg())
            else:
                fullInstruction.append(self.randImmediate())
        else:
            fullInstruction.append(self.randOpcode('one'))
            fullInstruction.append(target)
            fullInstruction.append(None)
        return fullInstruction

    def randPopInstructions(self):
        instructions = []
        targetReg = self.randReg()
        instructions.append(['push', targetReg, None])
        numInstructions = random.randrange(2, 6)
        for x in range(numInstructions):
            instructions.append(self.randTargetedInstruction(targetReg))
        instructions.append(['pop', targetReg, None])
        return instructions

    def randJump(self):
        jumps = self.instructions['control']
        return jumps[random.randrange(len(jumps))]

    def twoRandNum(limit):
        first = random.randrange(limit)
        second = random.randrange(limit-1)
        if first == second:
            second += 1 
        return [first, second]

    def randJumpInstructions(self):
        numInstructions = random.randrange(6, 16)
        instructions = []
        tempNums = Obfuscator.twoRandNum(len(self.registers))
        tempRegister = [self.registers[index] for index in tempNums]

        instructions.append(['push', tempRegister[0], None])
        instructions.append(['mov', tempRegister[0], tempRegister[1]])

        instructions.append(['cmp', tempRegister[0], tempRegister[1]])
        instructions.append([self.randJump(), '$+'+str(numInstructions)])
        for x in range(numInstructions):
            instructions.append(self.genRandInstruction())

        instructions.append(['pop', tempRegister[0], None])

        return instructions
    def randBenign(self):
        pass

obf = Obfuscator()
'''
file = open('testAsm.asm', 'r')
for line in file.readlines():
    print(Obfuscator.parseLine(line))
'''
randomInstructions = obf.randPopInstructions()
for instruction in randomInstructions:
    print(instruction)
