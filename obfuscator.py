import random
import re
import operator

from functools import reduce

class Obfuscator:

    def __initRegisters(self):
        self.registers = ['eax', 'ebx', 'ecx', 'edx', 'rax', 'rbx', 'rcx', 'rdx']
        for reg in range(1,15):
            self.registers.append(f"r{str(reg)}")
    def __initInstructions(self):
        twoOperand = ['add', 'and', 'mov', 'or', 'sub', 'xor', 'mul', 'shl', 'shr', 'ror', 'rol', 'lea']
        oneOperand = ['not', 'inc', 'dec']
        noOperand = ['nop']
        controlOperand = ['jmp', 'ja', 'jb', 'jbe', 'je', 'jg', 'jne', 'jnp', 'jp', 'jz']
        self.instructions['one'] = oneOperand
        self.instructions['two'] = twoOperand
        self.instructions['zero'] = noOperand
        self.instructions['control'] = controlOperand 

    def __init__(self):
        self.registers = []
        self.instructions = {}

        self.__initRegisters()
        self.__initInstructions()


    #generate random instruction operating on target register
    #   opcode will take at least 1 operand
    def randTargetedInstruction(self, target):
        choice = random.randrange(100)
        fullInstruction = []
        if choice < 80:
            fullInstruction = [self.randOpcode('two'), target]
            isRegister = random.choice([True, False])
            if isRegister:
                fullInstruction.append(self.randReg())
            else:
                fullInstruction.append(self.randImmediate())
        else:
            fullInstruction = [self.randOpcode('one'), target, None]
        return fullInstruction

    '''
    find interval of opcodes where target register in not used,
        no control flow operations are performed, and no changes
        to the stack are performed to randomly distribute resulting
        instructions
    '''
    def randPopInstructions(self):
        instructions = []
        targetReg = self.randReg()
        instructions.append(['push', targetReg, None])
        numInstructions = random.randrange(2, 6)
        for x in range(numInstructions):
            instructions.append(self.randTargetedInstruction(targetReg))
        instructions.append(['pop', targetReg, None])
        return instructions

    def randJump(self):
        jumps = self.instructions['control']
        return jumps[random.randrange(len(jumps))]

    '''Generate random sequence of instructions that will be skipped over
            TODO: fix registers being compared based on jump instruction
                  chosen
    '''
    def randJumpInstructions(self):
        numInstructions = random.randrange(6, 16)
        instructions = []
        tempNums = Obfuscator.twoRandNum(len(self.registers))
        tempRegister = [self.registers[index] for index in tempNums]

        instructions.append(['push', tempRegister[0], None])
        instructions.append(['mov', tempRegister[0], tempRegister[1]])

        instructions.append(['cmp', tempRegister[0], tempRegister[1]])
        instructions.append([self.randJump(), '$+'+str(numInstructions)])
        for x in range(numInstructions):
            instructions.append(self.genRandInstruction())

        instructions.append(['pop', tempRegister[0], None])

        return instructions

    #Find interval where target register is not used
    #   distribute instructions within that interval
    def randReversible(self):
        pass

    #generate two random numbers not equal to each other
    #   less than limit
    #   used to pick two random registers
    def twoRandNum(limit):
        first = random.randrange(limit)
        second = random.randrange(limit-1)
        if first == second:
            second += 1 
        return [first, second]

    def decToHex(number):
        if number < 0:
            return '-'+hex(number)[3:]+'h'
        return hex(number)[2:]+'h'

    def randReg(self):
        return self.registers[random.randrange(len(self.registers))]
    def randImmediate(self):
        return Obfuscator.decToHex(random.randrange(2**16))

    def parseLine(line):
        groups = re.match("(\\S+)( ([^,\n]*([^, \n])))? ?(, (\\S+))?", line).groups()
        return [groups[0], groups[2], groups[5]]

    def randOpcode(self, key):
        opcodeSet = self.instructions[key]
        return opcodeSet[random.randrange(len(opcodeSet))]

    def genRandInstruction(self):
        choice = random.randrange(100)
        fullInstruction = []
        if choice < 95:
            fullInstruction = self.randTargetedInstruction(self.randReg())
        else:
            fullInstruction = [self.randOpcode('zero'), None, None]
        return fullInstruction

    def insertItemsInList(target, position, generator):
        for i in range(len(items)):
            original.insert(i + position, items[i])

    #---------------------------------------
    # reversible functions
    #---------------------------------------

    def generator(function, numInstructions):
        num = numInstructions
        def wrapper_function():
            return function(num)
        return wrapper_function

    def genReversibleFunction(self, lower, upper, function, numInstructions):
        numbers = []
        for i in range(numInstructions-1):
            numbers.append(random.randrange(lower, upper))
        numbers.append(reduce(function, numbers, 0))
        return numbers
        #return [Obfuscator.decToHex(num) for num in numbers]

    #get n numbers that xor to 0
    #   numInstructions must be at least 2
    def genXor(self, numInstructions):
        return self.genReversibleFunction(0, 2**16, operator.xor, numInstructions)

    #get n numbers that add to 0
    #   numInstructions must be at least 2
    #   negative values will need to either be converted with sign extension
    #   or subtracted with sub opcode instead
    def genAdd(self, numInstructions):
        numbers = self.genReversibleFunction(-(2**16), 2**16, operator.add, numInstructions)
        numbers[-1] = -numbers[-1]
        return numbers