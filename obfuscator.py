import random
import re

class Obfuscator:
    def __initRegisters(self):
        self.registers = ['eax', 'ebx', 'ecx', 'edx', 'rax', 'rbx', 'rcx', 'rdx']
        for reg in range(1,15):
            self.registers.append("r"+str(reg))
        print(self.registers)
    def __initInstructions(self):
        twoOperand = ['add', 'and', 'mov', 'or', 'sub', 'xor', 'mul', 'shl', 'shr', 'ror', 'rol', 'lea']
        oneOperand = ['not', 'inc', 'dec']
        noOperand = ['nop']
        controlOperand = ['jmp', 'ja', 'jb', 'jbe', 'je', 'jg', 'jne', 'jnp', 'jp', 'jz']
        self.instructions['one'] = oneOperand
        self.instructions['two'] = twoOperand
        self.instructions['zero'] = noOperand
        self.instructions['control'] = controlOperand


    def __init__(self):
        self.registers = []
        self.instructions = {}

        self.__initRegisters()
        self.__initInstructions()


    #generate random instruction operating on target register
    #   opcode will take at least 1 operand
    def randTargetedInstruction(self, target):
        choice = random.randrange(100)
        fullInstruction = []
        if choice < 80:
            fullInstruction = [self.randOpcode('two'), target]
            isRegister = random.choice([True, False])
            if isRegister:
                fullInstruction.append(self.randReg())
            else:
                fullInstruction.append(self.randImmediate())
        else:
            fullInstruction = [self.randOpcode('one'), target, None]
        return fullInstruction

    '''
    find interval of opcodes where target register in not used,
        no control flow operations are performed, and no changes
        to the stack are performed to randomly distribute resulting
        instructions
    '''
    def randPopInstructions(self):
        instructions = []
        targetReg = self.randReg()
        instructions.append(['push', targetReg, None])
        numInstructions = random.randrange(2, 6)
        for x in range(numInstructions):
            instructions.append(self.randTargetedInstruction(targetReg))
        instructions.append(['pop', targetReg, None])
        return instructions

    def randJump(self):
        jumps = self.instructions['control']
        return jumps[random.randrange(len(jumps))]

    '''Generate random sequence of instructions that will be skipped over
            TODO: fix registers being compared based on jump instruction
                  chosen
    '''
    def randJumpInstructions(self):
        numInstructions = random.randrange(6, 16)
        instructions = []
        tempNums = Obfuscator.twoRandNum(len(self.registers))
        tempRegister = [self.registers[index] for index in tempNums]

        instructions.append(['push', tempRegister[0], None])
        instructions.append(['mov', tempRegister[0], tempRegister[1]])

        instructions.append(['cmp', tempRegister[0], tempRegister[1]])
        instructions.append([self.randJump(), '$+'+str(numInstructions)])
        for x in range(numInstructions):
            instructions.append(self.genRandInstruction())

        instructions.append(['pop', tempRegister[0], None])

        return instructions
    def randBenign(self):
        pass

    #generate two random numbers not equal to each other
    #   less than limit
    #   used to pick two random registers
    def twoRandNum(limit):
        first = random.randrange(limit)
        second = random.randrange(limit-1)
        if first == second:
            second += 1 
        return [first, second]

    def dexToHex(number):
        return hex(number)[2:]+'h'

    def randReg(self):
        return self.registers[random.randrange(len(self.registers))]
    def randImmediate(self):
        return Obfuscator.dexToHex(random.randrange(2**16))

    def parseLine(line):
        groups = re.match("(\\S+)( ([^,\n]*([^, \n])))? ?(, (\\S+))?", line).groups()
        return [groups[0], groups[2], groups[5]]

    def randOpcode(self, key):
        opcodeSet = self.instructions[key]
        return opcodeSet[random.randrange(len(opcodeSet))]


    def genRandInstruction(self):
        choice = random.randrange(100)
        fullInstruction = []
        if choice < 95:
            fullInstruction = self.randTargetedInstruction(self.randReg())
        else:
            fullInstruction = [self.randOpcode('zero'), None, None]
        return fullInstruction
